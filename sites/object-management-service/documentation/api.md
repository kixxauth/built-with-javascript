HTTP API
========

Write Server API
----------------
The Write Server API requires an HTTP Authorization header with a bearer token to allow access to any admin endpoint.

The token will be checked against the database to ensure it has write access to the specified scope. The token is checked by getting the admin database from S3 and checking for a simple `===` match. We are not concerned about replay attacks over HTTPS or lost access tokens for the first version of this service.

Tokens can be created by an admin using the Admin:ProvisionScopedToken API.

### PutObject
```
PUT /objects/:scope/:key

Authorization: Bearer [String token]
Content-Type: [MimeString contentType]
Content-Length: [Integer contentLength]
x-kc-storage-class: [Enum String STANDARD,INFREQUENT_ACCESS]
x-kc-video-processing: [Base64 encoded JSON]
```

- Authorization: Use the provided API token.
- Conent-Type: Use a standard mime string.
- Content-Length: Standard HTTP content-length header measured in bytes.
- x-kc-storage-class: A String included in the enum STANDARD or INFREQUENT_ACCESS.
- x-kc-video-processing: A JSON object String serialized as a Base64 String.

Validates the scope and key URL pathname parts to ensure safety and naming rules.

If the content type is a video and the `x-kc-video-processing` is set then create a MediaConvert job. When setting up the MediaConvert job, the `x-kc-storage-class` value is used to set the storage class for MediaConvert output to S3. If the content type is a video but there are no `x-kc-video-processing` instructions, then follow the normal procedure to store the object in S3.

__NOTE:__ For the first version of this service there we do not provide a way for clients to obtain status updates for the video processing jobs.

__NOTE:__ The STANDARD storage class must be used when a video will be processed with MediaConvert.

#### VideoProcessingInstructions
Base64 encode the JSON string. These are the defaults:

```json
{
    "type": "MP4_H264_AAC", // Required
    "video": {
        "height": 480, // Default
        "qualityLevel": 7, // Default
        "maxBitrate": 1000000 // Default
    },
    "audio": {}
}
```

For more information about resolution and QVBR see the [MediaConvert documentation](https://docs.aws.amazon.com/mediaconvert/latest/ug/cbr-vbr-qvbr.html).

### PutObject Response
When a new object is first created or an existing object is updated:

```json
{
    "data": {
        "type": "remote-object",
        "id": "55be03c5-e3da-479f-8e39-3403c35910f9",
        "scopeId": "testing-123",
        "key": "foo/image.jpg",
        "contentType": "image/jpeg",
        "storageClass": "STANDARD",
        "md5Hash": "0f36d4c3822d68f56f88fe595ab9ef87",
        "links": {
            "origin": "http://localhost:3003/origin/testing-123/foo/latest/image.jpg",
            "cdn": "https://kixx-stage.imgix.net/testing-123/foo/latest/image.jpg"
        }
    }
}
```


Admin Server API
----------------
Each admin endpoint requires an HTTP Authorization header with a bearer token to allow access to any admin endpoint.

__NOTE:__ The admin token must have been generated by a root admin with access to the database. This is done manually by the root admin.

### Admin:Home
`GET /admin`

Returns HTML; List all scopes in the database and provides a tool for creating scoped tokens for write API access.

The entire admin database is stored as a JSON object in S3. In this database object all the scopes are listed. Render the first Admin:ListObjects page link for each scope in the database.

### Admin:ListObjects
`GET /admin/objects?page_limit=integer&start_after_key=encodedString&scope=string`

Returns HTML; a list of links to object keys which can be used to view objects with `Admin:ViewObject`. Each object key can be expanded to show the available versions for the object.

Uses the S3 REST API listVersions action to list object keys and versions using the scope, startAfterKey, and pageLimit parameters. Parses the XML response from the S3 REST API, which returns the key and version IDs for each object, but *not* the metadata. Resolve the Admin:ViewObject link for each key and print it out in the HTML.

__NOTE:__ This will return keys for all versions of a particular object.

### Admin:ViewObject
`GET /admin/objects/:key/:version?`

Returns HTML; Display the object. Images and video are shown along with metadata, while other objects show only metadata. Objects in the ARCHIVE and DEEP_ARCHIVE storage classes are not shown, but provide a link to download them.

Uses the S3 REST API. Make a HEAD request to S3 to get metadata for the specified key and version. If no version is specified, then get the latest version by default. Use object metadata to render the appropriate HTML for each instance of the object, and provide download or playable links from the CDN or origin server.

### Admin:CreateScopedToken
```
POST /admin-rpc

{"method": "createScopedToken", "params": {"scopeId": "SCOPE_ID"}}
```

Returns JSON; `{ "result": {"scopeId": "SCOPE_ID","accessTokens": ["TOKEN_STRING"]}}`

If the scope does not exist in the database, then create it. Then generate a UUID as a token and associate it with the scope in the database.

Follows the [JSON RPC 2.0 Specification](https://www.jsonrpc.org/specification).

#### Design Decisions for Scope.generateAuthenticationToken()
```js
// Create a single access token for the scoped user.
scope.accessToken = "first access token"

// Then, revoke that access token and create a new one simulaniously:
scope.accessToken = "new access token"

// The remote service which was using the first token will no longer be able
// to access the object management service until we can update the token.
// This would lead to unwanted down time in our remote service.

// Instead, we use multiple access tokens:
scope.accessTokens = [
    "first access token"
]

// Then add the next one:
scope.accessTokens = [
    "first access token",
    "new access token"
]

// Now the remote service can continue using the first access token until we
// can update it to use the new access token
```

The *problem* is that we no longer have a way to revoke an access token without
manually updating the database file. But, this is ok for our minimum viable product.
We can be more sophisticated later.

Origin Server API
-----------------
The origin server has one purpose: Serve objects from S3 out on HTTP for CDNs to consume.

### GET
`GET /origin/:scope/:key/:version/:filename`

Fetch the latest version of the object from S3 and stream it back out. The :pathname + :filename make up the S3 key. The :version can be set to the string "latest" to get the latest version.
