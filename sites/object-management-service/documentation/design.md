Design
======

Use Cases
---------
All use cases are multitenant; meaning that many sites will be using this service and expect data to be segmented into virtual silos.

- Store images which ultimately get vended out to an image processing service like [imgix](https://imgix.com) or a CDN.
- Store web assets like CSS and JavaScript bundles to get vended out to CDNs.
- Process and store videos through [AWS MediaConvert](https://aws.amazon.com/mediaconvert/).
- Archive large files in cheap long term storage.

Design Goals
------------
Use cases and requirements which should be considered design constraints from the start.

- __Multitenancy__: Each site which hosts objects on the Object Management Service will be assigned a "scope" and must not be allowed to write objects to another site scope.
- __Idempotency__: Once an object is written to the service it cannot be updated. This is done to preserve strong version control and caching. If we have an updated version of `my-image.jpg` to replace our old one the service should create a new version of it without overwriting the previous version.
- __Admin Access__: There should be an authenticated admin which can view all items in all scopes.

Approach
--------
- Use AWS S3 for all data storage, including structured data.
    - The entire admin database is stored as a JSON object in S3
    - This leads to an inneficient admin API, but is a trade-off we should make for simplicity.
    - Use the built in S3 versioning mechanism to store multiple versions of the same object which achieves the itempotency design goal.
- Use a single server as both the origin, write, and admin APIs. The write and admin APIs *must* redirect to HTTPS.
- Use the [imgIX](https://imgix.com/) service to process images on-demand.
- Use AWS MediaConvert to process video before it is stored.

### S3 Storage Classes
The following storage classes are supported and can be specified when an object is put to the store. For now, the service does not support changing the storage class of an object after it is stored.

- STANDARD (S3 Standard - Infrequent Access)
- INFREQUENT_ACCESS (S3 Glacier Instant Retrieval)

Decisions
---------

### Use S3 versioned buckets, or not?

- __Advantage__ - Makes listing objects in the bucket easier for the admin panel in cases where we have many versions of the same object to list.

- __Disadvantage__ - The versionIDs generated by S3 may need to be URL encoded.

To use S3 versioning we'll need to allow object uploads to completely finish and cache them to disk to get the md5 hash to avoid uploading objects to S3 which already exist. To implement our own version of S3 versioning, we would need to do the same thing. There is an optimization with S3 versioning: We can determine if the object exists at all, in any version, and upload it without the md5 hash check if it does not exist.
